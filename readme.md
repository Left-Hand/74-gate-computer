# 本文档用于帮助您快速理解本微型计算机的构成
## 特征及功能

* 核心频率期待值为16Mhz，保守预估为8Mhz（暂未测试，待实体机研制出来后测试）
* 绝大多数指令为1T，不使用微指令 *部分另外说明
* 使用冯·诺伊曼架构（最初是使用哈佛架构）
* 使用74门作为本计算机的核心组件，并且不使用其他可编程组件（单片机，FPGA，CPLD等）

* 支持VGA显卡，分辨率为256*240。为4片is62c256分为两组乒乓工作，能够硬件上下回滚，自动修改地址为下一个字符
* 包含2个16位定时器，可屏蔽计时器信号，产生7位权中断
* PC(program counter)程序计数器为24位，能够寻址宽度为2M，前一半分配给AT28系列或是W27C系列芯片作为引导程序，后半部分为单片8Mbit的
sram，用于储存数据和运行程序
* 支持硬件ALU加速乘除操作，需要配置ALU相关寄存器，核心运算部分在16个时钟内完成（不包括配置寄存器及载入读出）

---
## 动机及声明

本人在16年左右看了commdore64的测评，认为非常新奇，于是整天幻想做一个自己的计算机，于17年开始构思（但是当时想的都是一些怪点子，比如用FR储存器作为Vram，使用摇摇棒作为显示屏等），直到下半年到18年出才正式开始用74构造切实可行的电路，并且陆续发布相关文章（黑历史bushi），最后在digital软件下逐步仿真出我想要的电路

主页：https://space.bilibili.com/28690875

专栏：https://www.kechuang.org/t/83193


本项目为开源项目，可能会出相关套件，请勿盗用。
由于我是一名在校高一年级高中生，因学业原因可能进度推展缓慢

---
## 文件

主目录下有一个POB.dig文件，为项目的主文件。使用hneemann的digtial作为仿真的ide（需要安装java），可以在 https://github.com/hneemann/Digital 中找到

作者的提供的库并不适合本项目，我将example/lib下的文件做了替换，解压主目录下的lib.zip文件并替换，方可使用本项目

ES目录下为旧的模块测试用文件，曾有模块化的打算，但是因无法看到底层电路的状态而放弃这一方案

---
## 原理
本计算机与其他微机不同，没有微指，例如C语言中的

```
A = B;
```
在大部分微机中，这条指令包括数个微指令：

```
1. 使B寄存器输出总线使能
2. 控制A载入总线中的数据
3. B寄存器输出结束
4. 检查其他操作...
```

但是，在本机中，绝大多数指令（不涉及修改返回PC值）为1T指令，即一条指令只花费一个周期

此机中，花费两个指令：
```
1. 切换为B寄存器输出到总线
2. 向A寄存器发出载入脉冲
```

再比如一个稍微复杂的（A，B分别为ALU内部的两个寄存器）：

```
C = A + B;
```
执行操作如下（对应一个周期）：

```
1. 切换为立即数寄存器输出到总线
2. 输出加法的ALU控制码（使用74181作为ALU，有多位控制译码线，无法简单操作）
3. ALU载入控制码
4. 切换为ALU输出到总线
5. C寄存器载入总线中的内容
```

故而，在本机中大部分操作使用译码器实现。有两种选通通道，P以及O，均为6位，各自可选通64个不同的脉冲，其区别在于
* P中只会在CLK主时钟发出脉冲时发出脉冲
* O会一直保存为上次载入之后的内容，且持续输出

这样，我们需要操作诸如A = B的操作，先修改O的指针以使B输出，再是P指向A载入的脉冲并放出脉冲，即可完成这样的操作

---
## 指令结构

单个指令为8bit，如果后缀了操作数，那么则为16bit单个操作的字节这样分配

| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
| -- | -- | -- | -- | -- | -- | -- | -- |
|下一位数据有无| 是否为O指令 | P5/O5 | P4/O4 | P3/O3 | P2/O2 |P1/O1 | P0/O0

需要说明的是，数据必须在指令之前给出，这使我们的汇编码写起来似乎有点反人类，但是这样做也是合情合理的

例如，A寄存器载入的指令为001(前包含一位0表示8进制)
下面是一段实现"A = 0x19"的汇编代码(此处为方便没有配置A寄存器,实际需要):

```
BUSO 0x19
ACP
```

这里我们的BUSO指使总线上的立即数寄存器输出(为000（八进制中的0，八进制不使用如0x，0b的前缀，而是0）)，它的出现同时为了引入0x19这样一个操作数，我们把它编译出来
```
| 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | //BUSO指令，下接操作数
| 0 | 0 | 0 | 1 | 0 | 0 | 1 | 1 | //操作数0x19
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | //A寄存器载入控制符
```
这样，我们的A寄存器就可以载入0x19这样的数字了其背后的逻辑控制稍显复杂，我们不做讨论

---

## 操作符
下面列出所有操作符（空为未定）

P操作符:

|序列号|汇编助记符|说明|
| --- | --- | --- |
|__000000__|NON|不做任何操作|
|000001|ACP|向A寄存器输出脉冲，视当前操作状态而定|
|000010|AMR|A寄存器清零|
|000011|STL|使A寄存器操作状态为左移|
|000100|STR|使A寄存器操作状态为右移|
|000101|LDM|使A寄存器操作状态为载入|
|000110|BLLD|使BL寄存器载入|
|000111|BHLD|使BH寄存器载入|
|__001000__|AILD|使A寄存器右侧移位寄存器载入|
|001001|MLD|使M寄存器载入（硬件乘法加速相关）|
|001010|STC|使ALU进位输入清零|
|001011|CLC|使ALU进位输入制位|
|001100|REC|使ALU进位输入为进位输出|
|001101|NF|第一次移位操作禁止（硬件除法加速相关）|
|001110|CAI|清除A寄存器右移移入数据（硬件乘法加速相关）|
|001111|ACLD|ALU控制符载入|
|__010000__|PCLLD|程序计数器最低字节预载入|
|010001|PCMLD|程序计数器中字节预载入|
|010010|PCHLD|程序计数器高字节预载入|
|010011|FBK|强制备份当前程序计数器至备份0|
|010100|RD|读写储存器操作为读|
|010101|WT|读写储存器操作为写|
|010110|RET|返回备份0的程序地址|
|010111|GED|程序计数器备份至备份1，读写预载入的地址数据并返回|
|__011000__|JMP|无条件跳转预载入的地址|
|011001|HLT|宕机|
|011010|JC|在ALU状态寄存器输出情况下，有进位输出跳转|
|011011|JNC|在ALU状态寄存器输出情况下，无进位输出跳转|
|011100|JZ|在ALU状态寄存器输出情况下，ALU得数为0时跳转|
|011101|JNZ|在ALU状态寄存器输出情况下，ALU得数不为0时跳转|
|011110|JV|在ALU状态寄存器输出情况下，ALU得数溢出跳转|
|011111|JNV|在ALU状态寄存器输出情况下，ALU得数未溢出跳转|
|__100000__|T0LLD|定时器T0低位载入|
|100001|T0HLD|定时器T0高位载入|
|100010|T1LLD|定时器T1低位载入|
|100011|T1HLD|定时器T1高位载入|
|100100|CTC|设置定时器中断许可|
|100101|CTI|设置中断许可|
|100110|INT3|强制中断3|
|100111|INT1|强制中断1|
|__101000__|IO0|IO0载入|
|101001|IO1|IO1载入|
|101010|CLD|C寄存器载入|
|101011|DLD|D寄存器载入|
|101100|IOLD|IO口控制数据流寄存器载入 |
|101101|||
|101110|||
|101111|||
|__110000__|||
|110001|||
|110010|||
|110011|||
|110100|||
|110101|||
|110110|||
|110111|||
|__111000__|SAM|设置A组屏幕输出|
|111001|IVS|切换为另一组屏幕输出|
|111010|WVGA|写VGA数据|
|111011|YP|设置Y偏转|
|111100|LXB|准备载入X地址|
|111101|LX|X地址载入|
|111110|LYB|准备载入Y地址|
|111111|LY|Y地址载入|

O操作符:

|序列号|汇编助记符|说明|
| --- | --- | --- |
|__000000__|BUSO|总线立即数寄存器输出|
|000001|UO|ALU输出|
|000010|DO|除法寄存器输出|
|000011|AOO|A寄存器右侧输出寄存器输出|
|000100|ACO|ALU状态输出|
|000101|PCLO|程序计数器低位预输入输出|
|000110|PCMO|程序计数器中位预输入输出|
|000111|PCHO|程序计数器高位预输入输出|
|__001000__|RDTO|读取的储存器数据输出|
|001001|INTO|中断信号编码输出|
|001010|CRO|C寄存器输出|
|001011|DRO|D寄存器输出|
|001100|IO0O|IO0输出|
|001101|IO1O|IO1输出|

---
## 汇编器及烧录

主目录下的asm.py文件，使用python写了一个简易的汇编器，用于将类似汇编代码更为底层的代码转换为机器码，省去人力编写的痛苦，写完之后将文档（txt格式）的地址修改进python代码中，在命令行的输出中可以找到编译出的机器码，将这段文本修改进入POB.dig文件下（实质上是xml文件），在ROM的data属性中替换为该段文本

---
## 各个寄存器逻辑详解

待补充

---
## 其他

koishi赛高
